import os
import json
import asyncio
import aiofiles
from file_tools import write_text_file
from error_handler import log_exception, catch_and_log

def update_relative_imports(file_content):
    replacements = [
        ("from file_tools import", "from .file_tools import"),
        ("from agent_spawner import", "from .agent_spawner import"),
        ("from executor import", "from .executor import"),
        ("from agent_tasks_writer import", "from .agent_tasks_writer import"),
        ("from memory_manager import", "from .memory_manager import"),
        # Replace old vector_memory imports with the new UltimateMemoryAgent import
        ("from vector_memory import add_embedding, query_embedding", "from vector_memory import UltimateMemoryAgent"),
        ("from error_handler import", "from .error_handler import"),
        ("from db_manager import", "from .db_manager import")
    ]
    for old, new in replacements:
        file_content = file_content.replace(old, new)
    return file_content

@catch_and_log("Copying tool module")
async def copy_tool_module(module_name, src_dir, dest_dir):
    src_path = os.path.join(src_dir, module_name)
    dest_path = os.path.join(dest_dir, module_name)
    exists = await asyncio.to_thread(os.path.isfile, src_path)
    if exists:
        async with aiofiles.open(src_path, 'r', encoding='utf-8') as f:
            content = await f.read()
        content = update_relative_imports(content)
        await write_text_file(dest_path, content)
    else:
        print(f"Warning: {module_name} not found in {src_dir}. Skipping copy.")

@catch_and_log("Writing agent tasks")
async def write_agent_tasks(agent_name, tasks, base_path="F:/agents"):
    agent_input_folder = os.path.join(base_path, agent_name, "input")
    tasks_filepath = os.path.join(agent_input_folder, "tasks.json")
    if not isinstance(tasks, list):
        raise ValueError("tasks must be a list of task objects.")
    for i, task in enumerate(tasks):
        if not isinstance(task, dict) or "name" not in task or "prompt" not in task:
            raise ValueError(f"Task at index {i} is invalid. It must be a dict with 'name' and 'prompt'.")
    json_content = json.dumps(tasks, indent=2)
    await write_text_file(tasks_filepath, json_content)
    return tasks_filepath

@catch_and_log("Creating agent package")
async def create_agent_package(agent_name, base_path="F:/agents"):
    agent_path = os.path.join(base_path, agent_name)
    input_path = os.path.join(agent_path, "input")
    output_path = os.path.join(agent_path, "output")
    tools_path = os.path.join(agent_path, "tools")
    agents_path = os.path.join(agent_path, "agents")
    for path in [agent_path, input_path, output_path, tools_path, agents_path]:
        await asyncio.to_thread(os.makedirs, path, exist_ok=True)
    init_file = os.path.join(tools_path, "__init__.py")
    exists = await asyncio.to_thread(os.path.exists, init_file)
    if not exists:
        async with aiofiles.open(init_file, "w", encoding="utf-8") as f:
            await f.write("# Marks the tools folder as a Python package.\n")
    tasks_file = os.path.join(input_path, "tasks.json")
    initial_tasks_content = """
[
    {
        "name": "Example Task",
        "prompt": "This is an example task. Replace with your own tasks!"
    }
]
""".strip()
    await write_text_file(tasks_file, initial_tasks_content)
    # Copy required tool modules into the child agent's tools folder.
    current_dir = os.path.dirname(os.path.abspath(__file__))
    tool_modules = [
        "agent_spawner.py",
        "agent_tasks_writer.py",
        "executor.py",
        "file_tools.py",
        "memory_manager.py",
        "vector_memory.py",
        "error_handler.py",
        "db_manager.py"
    ]
    for module in tool_modules:
        await copy_tool_module(module, current_dir, tools_path)
    # Create the main script for the child agent with an updated template
    main_script = os.path.join(agent_path, f"{agent_name}.py")
    # Note the updated import from vector_memory now uses UltimateMemoryAgent
    starter_code = f'''#!/usr/bin/env python3
"""
Child Agent: {agent_name}
----------------------------
This agent was generated by the Meta Agent. It processes tasks from its input folder,
executes commands, creates child agents, and can call its own functions.
"""

import os
import json
import asyncio
import aiofiles
from openai import AsyncOpenAI
from dotenv import load_dotenv

# Import necessary tool functions
from tools.file_tools import write_text_file, read_text_file, list_directory_contents
from tools.agent_spawner import create_agent_package
from tools.executor import run_agent_script
from tools.agent_tasks_writer import write_agent_tasks
from tools.memory_manager import log_event, get_recent_events
# Updated import: now import UltimateMemoryAgent instead of standalone add_embedding/query_embedding
from tools.vector_memory import UltimateMemoryAgent

# Load environment variables and instantiate the AsyncOpenAI client.
load_dotenv()
client = AsyncOpenAI(api_key=os.getenv("OPENAI_API_KEY", ""))

agent_id = "{agent_name}"
# Instantiate the vector memory agent
memory_agent = UltimateMemoryAgent()

async def chat_with_agent(messages, functions=None):
    response = await client.chat.completions.create(
        model="o3-mini",
        messages=messages,
        functions=functions or [],
        function_call="auto",
        reasoning_effort="medium"
    )
    return response

# Define agent functions that this child agent can call.
agent_functions = [
    {{
        "name": "create_agent_package",
        "description": "Spawn a new child agent with a specified name.",
        "parameters": {{
            "type": "object",
            "properties": {{
                "agent_name": {{"type": "string", "description": "Name of the new agent."}},
                "base_path": {{"type": "string", "description": "Optional base directory; default is F:/agents"}}
            }},
            "required": ["agent_name"]
        }}
    }},
    {{
        "name": "write_text_file",
        "description": "Write plain text content to a file.",
        "parameters": {{
            "type": "object",
            "properties": {{
                "filepath": {{"type": "string", "description": "Full file path, including file name."}},
                "content": {{"type": "string", "description": "Text content to write."}}
            }},
            "required": ["filepath", "content"]
        }}
    }},
    {{
        "name": "read_text_file",
        "description": "Read plain text content from a file.",
        "parameters": {{
            "type": "object",
            "properties": {{
                "filepath": {{"type": "string", "description": "The file path to read."}}
            }},
            "required": ["filepath"]
        }}
    }},
    {{
        "name": "run_agent_script",
        "description": "Execute the main script for an agent.",
        "parameters": {{
            "type": "object",
            "properties": {{
                "agent_name": {{"type": "string", "description": "Name of the agent to run."}},
                "base_path": {{"type": "string", "description": "Base directory; default is F:/agents"}}
            }},
            "required": ["agent_name"]
        }}
    }},
    {{
        "name": "write_agent_tasks",
        "description": "Write tasks to an agent's tasks.json and run that agent.",
        "parameters": {{
            "type": "object",
            "properties": {{
                "agent_name": {{"type": "string", "description": "Name of the agent to receive tasks."}},
                "tasks": {{
                    "type": "array",
                    "description": "Array of tasks, each with a 'name' and 'prompt'.",
                    "items": {{
                        "type": "object",
                        "properties": {{
                            "name": {{"type": "string"}},
                            "prompt": {{"type": "string"}}
                        }},
                        "required": ["name", "prompt"]
                    }}
                }},
                "base_path": {{"type": "string", "description": "Optional base directory; default is F:/agents"}}
            }},
            "required": ["agent_name", "tasks"]
        }}
    }},
    {{
        "name": "list_directory_contents",
        "description": "List the files and folders in a given directory.",
        "parameters": {{
            "type": "object",
            "properties": {{
                "directory_path": {{"type": "string", "description": "Directory path."}}
            }},
            "required": ["directory_path"]
        }}
    }}
]

async def process_function_call(message, conversation, processed_calls):
    if message.function_call is None:
        return False
    call_signature = f"{{message.function_call.name}}-{{message.function_call.arguments}}"
    if call_signature in processed_calls:
        return False
    processed_calls.add(call_signature)
    func_name = message.function_call.name
    try:
        args = json.loads(message.function_call.arguments)
    except Exception as e:
        error_msg = f"Error: invalid JSON for function arguments: {{message.function_call.arguments}}"
        conversation.append({{"role": "assistant", "content": error_msg}})
        print(error_msg)
        return True

    if func_name == "write_text_file":
        filepath = args["filepath"]
        content = args["content"]
        await write_text_file(filepath, content)
        tool_result = f"Successfully wrote text to: {{filepath}}"
    elif func_name == "create_agent_package":
        new_agent_name = args["agent_name"]
        base_path = args.get("base_path", "F:/agents")
        await create_agent_package(new_agent_name, base_path)
        tool_result = f"Created agent '{{new_agent_name}}' at: {{base_path}}"
    elif func_name == "read_text_file":
        filepath = args["filepath"]
        try:
            file_content = await read_text_file(filepath)
            tool_result = f"Content of {{filepath}}:\\n{{file_content}}"
        except Exception as e:
            tool_result = f"Error reading file '{{filepath}}': {{str(e)}}"
    elif func_name == "run_agent_script":
        new_agent_name = args["agent_name"]
        base_path = args.get("base_path", "F:/agents")
        try:
            code, stdout, stderr = await run_agent_script(new_agent_name, base_path)
            tool_result = f"Agent '{{new_agent_name}}' executed successfully.\\nSTDOUT:\\n{{stdout}}\\nSTDERR:\\n{{stderr}}"
        except Exception as e:
            tool_result = f"Error executing agent script: {{e}}"
    elif func_name == "write_agent_tasks":
        new_agent_name = args["agent_name"]
        tasks = args["tasks"]
        base_path = args.get("base_path", "F:/agents")
        await write_agent_tasks(new_agent_name, tasks, base_path)
        try:
            code, stdout, stderr = await run_agent_script(new_agent_name, base_path)
            tool_result = f"Agent '{{new_agent_name}}' executed successfully.\\nSTDOUT:\\n{{stdout}}\\nSTDERR:\\n{{stderr}}"
        except Exception as e:
            tool_result = f"Error executing agent script: {{e}}"
    elif func_name == "list_directory_contents":
        directory_path = args["directory_path"]
        tool_result = await list_directory_contents(directory_path)
    else:
        tool_result = f"Function '{{func_name}}' not recognized."

    conversation.append({{"role": "assistant", "content": tool_result}})
    print("Tool result:", tool_result)
    return True

async def run_tasks():
    tasks_file = os.path.join(os.path.dirname(__file__), "input", "tasks.json")
    exists = await asyncio.to_thread(os.path.isfile, tasks_file)
    if not exists:
        print("No tasks.json found. Exiting.")
        return
    async with aiofiles.open(tasks_file, "r", encoding="utf-8") as f:
        tasks = json.loads(await f.read())
    for task in tasks:
        prompt = task.get("prompt", "No prompt provided.")
        print(f"\\n--- Running Task: {{task.get('name', 'Unnamed Task')}} ---")
        conversation = [{{"role": "user", "content": prompt}}]
        processed_calls = set()
        while True:
            response = await chat_with_agent(conversation, functions=agent_functions)
            message = response.choices[0].message
            if message.function_call is not None:
                if await process_function_call(message, conversation, processed_calls):
                    continue
            assistant_reply = message.content or ""
            print("Response:", assistant_reply)
            conversation.append({{"role": "assistant", "content": assistant_reply}})
            break

async def main():
    print("Child Agent is processing tasks...")
    await run_tasks()

if __name__ == "__main__":
    asyncio.run(main())
'''
    await write_text_file(main_script, starter_code)
    try:
        await asyncio.to_thread(os.chmod, main_script, 0o755)
    except Exception as e:
        log_exception(e, f"Unable to set executable permissions on {main_script}")
    return agent_path
